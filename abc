


hello NppFtp

//#include <opencv2/core/core.hpp>
//#include <stdio.h>


		
		// read the frame
		// add into frame graph
		// local BA
		// optimize graph


#include <iostream>
#include <opencv2/core/core.hpp>
#include <stdio.h>

cv::Mat read_flow(const char* file_name) {

	FILE* file = NULL;
	file = fopen(file_name, "rb");
	if (!file) {
		perror("Error");
		std::cout << "Unable to open file:" << file_name << std::endl;
		return;
	}
	int size_type[3];

	fread(size_type, sizeof(size_type), 1, file);

	cv::Mat flow = cv::Mat(size_type[0], 
		size_type[1], size_type[2]);
	fread(size_type, sizeof(size_type), 1, file);

	 = { flow.cols, flow.rows, flow.type() };
	fwrite(size_type, sizeof(size_type), 1, file);
	for (int i = 0; i < flow.rows; i++) {
		fwrite(flow.ptr(i), flow.step[0], 1, file);
	}
	fclose(file);

	return cv::Mat();

}


int main(int argc, char** argv) {

	std::cout << "hello local" << std::endl;	
	//while (true) {
	
	char file_name[256];
	for (int i = 0; i < 4; i++) {

		sprintf(file_name, "temp/flow/flow_%d_%d.flw", 
			i, i+1);
		cv::Mat frame = read_flow(file_name);
		
		// read the frame
		// add into frame graph
		// local BA
		// optimize graph

	}
	

}

		std::cout << "Please specify a video file.\n";


#include <stdio.h>							// sprintf
#include <iostream>							// std::cout
#include <opencv2/highgui/highgui.hpp>		// cv::VideoCapture
#include <opencv2/imgproc/imgproc.hpp>		// cv::cvtColor
#include <opencv2/video/video.hpp>			// cv::calcOpticalFlowFarneback
#include <unistd.h> 						// getcwd()


#include "dslam.h"


void save_flow(cv::Mat& flow, int prev_id, int next_id) {


	char file_name[256];
	sprintf(file_name, "temp/flow/flow_%d_%d.flw", prev_id, next_id);

	FILE* file = NULL;
	file = fopen(file_name, "wb");
	if (!file) {
		perror("Error");
		std::cout << "Unable to open file:" << file_name << std::endl;
		return;
	}
	
	int size_type[3] = { flow.cols, flow.rows, flow.type() };
	fwrite(size_type, sizeof(size_type), 1, file);
	for (int i = 0; i < flow.rows; i++) {
		fwrite(flow.ptr(i), flow.step[0], 1, file);
	}
	fclose(file);
	std::cout << "Write flow to file:" << file_name << std::endl;

}


int main(int argc, char** argv) {

	char buffer[1024];
	if (getcwd(buffer, 1024)) {
		std::cout << "cwd:" << buffer << std::endl;
	}
	std::cout << argv[0] << std::endl;
	if (argc < 2) { 
		std::cout << "Please specify a video file.\n";
		return -1;
	}

    cv::VideoCapture capture(argv[1]);
    if(!capture.isOpened()) {
		std::cout << "file not found:" << argv[1] << std::endl;
		return -1;
	}

	cv::Mat prev, next, frame, gray;
	cv::Mat flow;
	int times = 0;
	while(capture.read(frame) && times < 5) {

		cv::cvtColor(frame, gray, CV_BGR2GRAY);
		if (prev.empty()) {
			prev = gray;
		}
		else {
			next = gray;
			cv::calcOpticalFlowFarneback(prev, next, flow, 0.5, 3, 15, 3, 5, 1.2, 0);
			save_flow(flow, times-1, times);
		}
		times++;
	}
	

	std::cout << "hello flow" << std::endl;	
}

/*

	
			//write_ptr = fopen("test.bin","wb");  // w for write, b for binary
			//fwrite(buffer,sizeof(buffer),1,write_ptr); // write 10 bytes from our buffer

			//std::cout << "calcOpticalFlowFarneback(" << times << ")" << std::endl;
			//save(flow);

	for (int i = 0; i < 5; i++) {


    Mat edges;
    namedWindow("edges",1);
    for(;;)
    {
        Mat frame;
        cap >> frame; // get a new frame from camera
        cvtColor(frame, edges, CV_BGR2GRAY);
        GaussianBlur(edges, edges, Size(7,7), 1.5, 1.5);
        Canny(edges, edges, 0, 30, 3);
        imshow("edges", edges);
        if(waitKey(30) >= 0) break;
    }


	open video
	foreach frame {
		calc flow();
		if (step = N) {
			save flow double side;
		}
	}


	const char* file_name = NULL;
	if (argc > 1) {
		file_name = ;
	}
	else {
		file_name = "data/videos/720.mp4";
	}


	char buffer[1024];
	if (getcwd(buffer, 1024)) {
		std::cout << "cwd:" << buffer << std::endl;
	}

*/







flow:
	utils/flow data/videos/720.mp4



\begin{subfigure}{0.4\textwidth}
	\includegraphics[width=0.4\linewidth]{docs/soba/mr-flow1.jpg}
	\caption{Illustration1 of MR-FLOW}
\end{subfigure}

\begin{subfigure}{0.4\textwidth}
	\includegraphics[width=0.4\linewidth]{docs/soba/mr-flow1.jpg}
	\caption{Illustration1 of MR-FLOW}
\end{subfigure}



\begin{subfigure}{0.32\textwidth}
	\includegraphics[width=\linewidth]{docs/soba/header_scene_flow.jpg}
	\caption{Illustration2 of MR-FLOW}
\end{subfigure}

\begin{subfigure}{0.32\textwidth}
	\includegraphics[width=\linewidth]{docs/soba/header_scene_flow.jpg}
	\caption{Illustration2 of MR-FLOW}
\end{subfigure}


\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{docs/soba/mr-flow1.jpg}
	\caption{Illustration1 of MR-FLOW}
\endminipage \hfill

\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{docs/soba/header_scene_flow.jpg}
	\caption{Illustration2 of MR-FLOW}
\endminipage \hfill

\minipage{0.32\textwidth}
	\includegraphics[width=\linewidth]{docs/soba/header_scene_flow.jpg}
	\caption{Illustration2 of MR-FLOW}
\endminipage

\begin{displaymath}

E=\sum (x'Fx)^2

\end{displaymath}


@inproceedings{Furukawa2008Accurate,
  title={Accurate camera calibration from multi-view stereo and bundle adjustment},
  author={Furukawa, Yasutaka and Ponce, Jean},
  booktitle={Computer Vision and Pattern Recognition, 2008. CVPR 2008. IEEE Conference on},
  pages={257-268},
  year={2008},
}


\cite{Bai2016Exploiting}\cite{Oisel2001Epipolar}\cite{Valgaerts2008A}\cite{Wedel2009Structure}\cite{Yuan2007Detecting}. The top monocular optical flow method on the KITTI-2012 benchmark estimates the fundamental matrix and computes flow along the epipolar lines [40]. This approach is limited to fully rigid scenes. Wedel et al. [39] compute the fundamental matrix and regularize optical flow to lie along the epipolar lines. If they detect independent motion, they revert to standard optical flow for the entire frame. 



@article{Heeger1992Subspace,
  title={Subspace methods for recovering rigid motion I: Algorithm and implementation},
  author={Heeger, David J. and Jepson, Allan D.},
  journal={International Journal of Computer Vision},
  volume={7},
  number={2},
  pages={95-117},
  year={1992},
}



@article{Horn1988Direct,
  title={Direct methods for recovering motion},
  author={Horn, Berthold K. P. and Weldon, E. J.},
  journal={International Journal of Computer Vision},
  volume={2},
  number={1},
  pages={51-76},
  year={1988},
}


@inproceedings{Bai2016Exploiting,
  title={Exploiting Semantic Information and Deep Matching for Optical Flow},
  author={Bai, Min and Luo, Wenjie and Kundu, Kaustav and Urtasun, Raquel},
  booktitle={European Conference on Computer Vision},
  pages={154-170},
  year={2016},
}

@article{Oisel2001Epipolar,
  title={Epipolar constrained motion estimation for reconstruction from video sequences},
  author={Oisel, Lionel and Memin, Etienne and Morin, Luce and Labit, Claude},
  year={2001},
}

@inproceedings{Valgaerts2008A,
  title={A Variational Model for the Joint Recovery of the Fundamental Matrix and the Optical Flow},
  author={Valgaerts, Levi and Bruhn, AndrÃ©s and Weickert, Joachim},
  booktitle={Dagm Symposium on Pattern Recognition},
  pages={314-324},
  year={2008},
}

@inproceedings{Wedel2009Structure,
  title={Structure- and motion-adaptive regularization for high accuracy optic flow},
  author={Wedel, Andreas and Cremers, Daniel and Pock, Thomas and Bischof, Horst},
  booktitle={IEEE  International Conference on Computer Vision},
  pages={1663-1668},
  year={2009},
}


@article{Yuan2007Detecting,
  title={Detecting Motion Regions in the Presence of a Strong Parallax from a Moving Camera by Multiview Geometric Constraints},
  author={Yuan, Chang and Medioni, Gerard and Kang, Jinman and Cohen, Isaac},
  journal={IEEE Transactions on Pattern Analysis & Machine Intelligence},
  volume={29},
  number={9},
  pages={1627-1641},
  year={2007},
}





	pdftotext $@

import os


def main() :
	str = os.popen("find -name *.tex").read()
	texs = str.split('\n')
	for tex_name in texs : 
		if not tex_name : 
			continue
		pdf_name = os.path.splitext(tex_name)[0]+".pdf"
		bib_name = os.path.splitext(tex_name)[0]+".bib"
		if (os.path.isfile(bib_name)) :
			#if (os.path.isfile(pdf_name) and os.path.getmtime(pdf_name) > os.path.getmtime(tex_name) and os.path.getmtime(pdf_name) > os.path.getmtime(bib_name)) :
				#continue
			print("xelatex -output-directory=%s %s" % (os.path.dirname(tex_name), tex_name))
			print("--------1: %s %s--------" % ("xelatex", tex_name))
			os.system("xelatex -output-directory=%s %s" % (os.path.dirname(tex_name), tex_name))
			aux_name = os.path.splitext(tex_name)[0]+".aux"
			print("--------2: %s %s--------" % ("bibtex", aux_name))
			os.system("bibtex %s" % aux_name)
			print("--------3: %s %s--------" % ("xelatex", tex_name))
			os.system("xelatex -output-directory=%s %s" % (os.path.dirname(tex_name), tex_name))
			print("--------4: %s %s--------" % ("xelatex", tex_name))
			os.system("xelatex -output-directory=%s %s" % (os.path.dirname(tex_name), tex_name))
		else :
			#if (os.path.isfile(pdf_name) and os.path.getmtime(pdf_name) > os.path.getmtime(tex_name)) :
				#continue
			print("--------straint: %s %s--------" % ("xelatex", tex_name))
			os.system("xelatex -output-directory=%s %s" % (os.path.dirname(tex_name), tex_name))
	'''
	find all tex file
	if associated with bib file	
		if (pdf is empy or old than tex or bib)
			compile bbl and pdf
	else if (pdf is empty or old than tex) 
		compile pdf
	endif
	'''

if __name__ == "__main__" :
	main()


NAME = ddslam

TEXS=$(wildcard docs/*.tex)
PDFS=$(TEXS:%.tex=%.pdf)

#SRCS=$(wildcard  src/*.cpp)
#OBJS=$(SRCS:%.cpp=%.o)
UTL_SRCS=$(wildcard  utils/*.cpp)
UTLS=$(UTL_SRCS:%.cpp=%.utl)


LIBS = -lopencv_highgui -lopencv_core -lopencv_imgproc -lopencv_video



all : pdfs utls 

pdfs : $(PDFS)

utls : $(UTLS)

%.pdf : %.tex %.bib
	@echo 0
	xelatex -output-directory=docs $<
	@echo 1 
	bibtex $*.aux
	@echo 2
	xelatex -output-directory=docs $<
	@echo 3
	xelatex -output-directory=docs $<

%.bib :
	touch $@

%.utl : %.cpp 
	g++ -g $< $(LIBS) -o $@

clean:
	find -name "*~" -type f -delete
	find -name "*.flw" -type f -delete
	find -name "*.aux" -type f -delete
	find -name "*.log" -type f -delete
	find -name "*.bbl" -type f -delete
	find -name "*.blg" -type f -delete
	find -name "*.pdf" -type f -delete
	find -name "*.utl" -type f -delete

debug_flow:
	gdb utils/flow.utl

flow:
	utils/flow data/videos/720.mp4

echo:
	@echo LIBS:
	@echo $(LIBS)
	@echo UTILS:
	@echo $(UTILS)
	@echo UTLI_SRCS:
	@echo $(UTLI_SRCS)
	@echo TOOL_OBJS:
	@echo $(TOOL_OBJS)



NAME = ddslam

TEXS=$(wildcard docs/*.tex)
PDFS=$(TEXS:%.tex=%.pdf)
#LOGS=$(TEXS:%.tex=%.log)
#AUXS=$(TEXS:%.tex=%.aux)
BIBS=$(TEXS:%.tex=%.bib)
#BBLS=$(TEXS:%.tex=%.bbl)
#BLGS=$(TEXS:%.tex=%.blg)

SRCS=$(wildcard  src/*.cpp)
OBJS=$(SRCS:%.cpp=%.o)
UTLI_SRCS=$(wildcard  utils/*.cpp)
UTILS=$(UTLI_SRCS:%.cpp=%.utl)
BIB=

LIBS = -lopencv_highgui -lopencv_core -lopencv_imgproc -lopencv_video

all : pdfs utils 

pdfs : $(PDFS)

utils : $(UTILS)


%.pdf : %.tex %.bib
	xelatex -output-directory=docs $<

%.bib :

%.utl : %.cpp 
	g++ -g $< $(LIBS) -o $@


	@g++ -g $< $(LIBS) -o $@

clean:
	@echo Remove temporary files
	@rm -f $(PDFS) $(LOGS) $(AUXS) $(UTILS) $(BBLS) $(BLGS)
	@find -name "*~" -type f -delete
	@find -name "*.flw" -type f -delete
	@find -name "*.aux" -type f -delete
	@find -name "*.log" -type f -delete
	@find -name "*.bbl" -type f -delete
	@find -name "*.blg" -type f -delete

debug_flow:
	gdb utils/flow

flow:
	utils/flow data/videos/720.mp4

echo:
	@echo LIBS:
	@echo $(LIBS)
	@echo UTILS:
	@echo $(UTILS)
	@echo UTLI_SRCS:
	@echo $(UTLI_SRCS)
	@echo TOOL_OBJS:
	@echo $(TOOL_OBJS)


other:
	@echo $< $(wildcard $(BIB))
	@echo ----------------------------
	aaabbbccc aaaabbbccc
	@echo ---------------------------------
	xelatex -output-directory=docs $<
	@echo ---------------------------------
	bibtex  $(basename $<).aux
	@echo ---------------------------------
	xelatex -output-directory=docs $<
	@echo ---------------------------------
	xelatex -output-directory=docs $<

	$(eval BIB=$(join $(basename $<),.bib)) 
	@echo $(BIB)
	$(eval FIND=$(wildcard $(join $(basename $<),.bib)) 
	@echo $(FIND)
	echo $(word 1, $<)
	echo $(word 2, $<)
$(BIBS) :

$(UTILS) : % : %.cpp 
$(PDFS) : %.pdf : %.tex %.bib 
	@echo $^
	@echo $(wildcard $(word 2, $^))
	$(eval BIB=$(word 2, $^))
	$(eval FIND=$(wildcard $(BIB)))
	@echo BIB=$(BIB)
	@echo FIND=$(FIND)
ifeq ($(BIB), $(FIND))
	echo aaa
else
	echo bbb
endif	

$(BIBS) :

$(UTILS) : % : %.cpp 
	@echo g++ -g $< -o $@
ifeq ("$(BIB)","$(FIND)")
	@echo yes!
else
	@echo no!
endif
ifeq ($(word 2, $<), )
	echo no bib
else
	echo has bib
endif

#$(error err)
#$(BBLS) : %.bbl : %.tex %.bib
#@echo $< $@ $(word 2,$^)
#@echo -------------------
#$(UTILS) : $(TOOL_OBJS) 
#	g++ -g $< -o $@

#$(UTILS_OBJS) : %.o : %.cpp
#	g++ -c -g $< -o $@
#TOOL_OBJS=$(UTLI_SRCS:%.cpp=%.o)
#rm -f *~ docs/*~ srcs/*~ utils/*~ html/*~
#UTILS = $(basename $(UTLI_SRCS))
#	@echo NAMES:
#	@echo $(NAMES)

# 
#TARGETS = $(NAME).pdf $(NAME).dvi
#
# $(TARGETS) : $(NAME).tex
#	latex $(NAME).tex
#	
#
#dvi:
#	xdvi $(NAME).dvi
#rm $(TARGETS) $(NAME).aux $(NAME).log

\subsection{Web Page}

combox: video1, video2...\\
button: flow, coarse, refine
\iffalse
\section{Detail Design}

\subsection{Work.php}
flow.cpp::main()\\
\indent OpenVideo()\\
\indent ForEachFrame()
\indent CalcFlow()

\subsection{Work.php::ClacFlow}
Work.php::CalcFlow()\\
\indent output is exec(../utils/flow video name)\\
\indent echo output


\subsection{CPP::flow}
CPP::flow()\\
\indent aaa

\fi



